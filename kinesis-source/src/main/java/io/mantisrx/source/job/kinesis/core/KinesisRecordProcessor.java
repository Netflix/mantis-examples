package io.mantisrx.source.job.kinesis.core;

import com.amazonaws.services.kinesis.clientlibrary.exceptions.InvalidStateException;
import com.amazonaws.services.kinesis.clientlibrary.exceptions.ShutdownException;
import com.amazonaws.services.kinesis.clientlibrary.interfaces.IRecordProcessorCheckpointer;
import com.amazonaws.services.kinesis.clientlibrary.interfaces.v2.IRecordProcessor;
import com.amazonaws.services.kinesis.clientlibrary.types.InitializationInput;
import com.amazonaws.services.kinesis.clientlibrary.types.ProcessRecordsInput;
import com.amazonaws.services.kinesis.clientlibrary.types.ShutdownInput;
import com.amazonaws.services.kinesis.model.Record;
import io.mantisrx.source.job.kinesis.domain.KinesisAckable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import rx.Observable;
import rx.schedulers.Schedulers;
import rx.subjects.PublishSubject;

import java.nio.charset.Charset;
import java.util.Iterator;
import java.util.Queue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

/**
 * Implements our IRecordProcessor for consuming data from Kinesis.
 */
public class KinesisRecordProcessor implements IRecordProcessor {

  private static Logger logger = LoggerFactory.getLogger(KinesisRecordProcessor.class);
  private final Integer ackInterval;
  private final Queue<KinesisAckable> queue;
  private final PublishSubject<String> acks;
  private final Charset charset = Charset.forName("UTF-8");
  private final AtomicReference<IRecordProcessorCheckpointer> checkpointer =
    new AtomicReference<IRecordProcessorCheckpointer>(null);

  public KinesisRecordProcessor(Queue<KinesisAckable> queue, Integer ackInterval) {
    super();
    this.queue = queue;
    this.acks = PublishSubject.create();
    this.ackInterval = ackInterval;
  }

  /**
   * Initialize will setup a checkpoint on an interval specified by the user.
   */
  public void initialize(InitializationInput initializationInput) {

      Observable.interval(this.ackInterval, TimeUnit.SECONDS)
              .withLatestFrom(this.acks, (tick, ack) -> ack)
              .observeOn(Schedulers.newThread())
              .forEach(ack -> {
                  logger.info("Checkpointing at: " + ack + ".");
                  try {
                      this.checkpointer.get().checkpoint(ack);
                  } catch (InvalidStateException ex) {
                      logger.info("Invalid State Exception while checkpointing: " + ex.getMessage());
                  } catch (ShutdownException ex) {
                      logger.info("Shutdown Exception while checkpointing: " + ex.getMessage());
                  }
              });
  }

    /**
     * Processes the records in a batch from Kinesis.
     *
     * Backpressure: Kinesis Client Library (KCL) will not request more records if there is an ongoing call to
     * processRecords. Therefore in order to implement backpressure we use offer below with no timeout, effectively
     * blocking this function if the queue is full.
     *
     * @param processRecordsInput An input object generated by the KCL.
     */
  public void processRecords(ProcessRecordsInput processRecordsInput) {
      if (checkpointer.get() == null) {
          this.checkpointer.set(processRecordsInput.getCheckpointer());
      }

      Iterator<Record> recordIterator = processRecordsInput.getRecords().iterator();
      while (recordIterator.hasNext()) {
          Record rec = recordIterator.next();
          KinesisAckable datum =
            new KinesisAckable(new String(rec.getData().array(), charset), rec.getSequenceNumber(), this.acks);
          queue.offer(datum);
      }
  }

  /**
   * Can be used to implement any sort of tear down logic for the record
   * processor. May be useful for providing final checkpointing.
   */
  public void shutdown(ShutdownInput shutdownInput) {
      logger.info("Initiating shutdown procedure: " + shutdownInput.getShutdownReason());
  }
}
